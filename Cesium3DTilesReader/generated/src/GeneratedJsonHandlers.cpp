// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesBoundingVolumeS2JsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesBoundingVolumeS2.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesBoundingVolumeS2JsonHandler::
    Extension3dTilesBoundingVolumeS2JsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _token(),
      _minimumHeight(),
      _maximumHeight() {}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesBoundingVolumeS2* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesBoundingVolumeS2JsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesBoundingVolumeS2(
      Cesium3DTiles::Extension3dTilesBoundingVolumeS2::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesBoundingVolumeS2())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesBoundingVolumeS2&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesBoundingVolumeS2JsonHandler::
    readObjectKeyExtension3dTilesBoundingVolumeS2(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesBoundingVolumeS2& o) {
  using namespace std::string_literals;

  if ("token"s == str)
    return property("token", this->_token, o.token);
  if ("minimumHeight"s == str)
    return property("minimumHeight", this->_minimumHeight, o.minimumHeight);
  if ("maximumHeight"s == str)
    return property("maximumHeight", this->_maximumHeight, o.maximumHeight);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesContentGltfLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesContentGltfLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesContentGltfLegacyJsonHandler::
    Extension3dTilesContentGltfLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void Extension3dTilesContentGltfLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesContentGltfLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesContentGltfLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesContentGltfLegacy(
      Cesium3DTiles::Extension3dTilesContentGltfLegacy::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesContentGltfLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesContentGltfLegacy())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesContentGltfLegacy&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesContentGltfLegacyJsonHandler::
    readObjectKeyExtension3dTilesContentGltfLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesContentGltfLegacy& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionContent3dTilesMetadataLegacyJsonHandler.h"

#include <Cesium3DTiles/ExtensionContent3dTilesMetadataLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ExtensionContent3dTilesMetadataLegacyJsonHandler::
    ExtensionContent3dTilesMetadataLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _group() {}

void ExtensionContent3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ExtensionContent3dTilesMetadataLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionContent3dTilesMetadataLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionContent3dTilesMetadataLegacy(
      Cesium3DTiles::ExtensionContent3dTilesMetadataLegacy::TypeName,
      str,
      *this->_pObject);
}

void ExtensionContent3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              Cesium3DTiles::ExtensionContent3dTilesMetadataLegacy())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::ExtensionContent3dTilesMetadataLegacy&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionContent3dTilesMetadataLegacyJsonHandler::
    readObjectKeyExtensionContent3dTilesMetadataLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::ExtensionContent3dTilesMetadataLegacy& o) {
  using namespace std::string_literals;

  if ("group"s == str)
    return property("group", this->_group, o.group);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionTile3dTilesMetadataLegacyJsonHandler.h"

#include <Cesium3DTiles/ExtensionTile3dTilesMetadataLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ExtensionTile3dTilesMetadataLegacyJsonHandler::
    ExtensionTile3dTilesMetadataLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classProperty(),
      _properties() {}

void ExtensionTile3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ExtensionTile3dTilesMetadataLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionTile3dTilesMetadataLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionTile3dTilesMetadataLegacy(
      Cesium3DTiles::ExtensionTile3dTilesMetadataLegacy::TypeName,
      str,
      *this->_pObject);
}

void ExtensionTile3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::ExtensionTile3dTilesMetadataLegacy())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::ExtensionTile3dTilesMetadataLegacy&>(
          value));
}

CesiumJsonReader::IJsonHandler* ExtensionTile3dTilesMetadataLegacyJsonHandler::
    readObjectKeyExtensionTile3dTilesMetadataLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::ExtensionTile3dTilesMetadataLegacy& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionTileset3dTilesMetadataLegacyJsonHandler.h"

#include <Cesium3DTiles/ExtensionTileset3dTilesMetadataLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ExtensionTileset3dTilesMetadataLegacyJsonHandler::
    ExtensionTileset3dTilesMetadataLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _schema(context),
      _schemaUri(),
      _statistics(context),
      _groups(context),
      _tileset(context) {}

void ExtensionTileset3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ExtensionTileset3dTilesMetadataLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionTileset3dTilesMetadataLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionTileset3dTilesMetadataLegacy(
      Cesium3DTiles::ExtensionTileset3dTilesMetadataLegacy::TypeName,
      str,
      *this->_pObject);
}

void ExtensionTileset3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              Cesium3DTiles::ExtensionTileset3dTilesMetadataLegacy())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::ExtensionTileset3dTilesMetadataLegacy&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionTileset3dTilesMetadataLegacyJsonHandler::
    readObjectKeyExtensionTileset3dTilesMetadataLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::ExtensionTileset3dTilesMetadataLegacy& o) {
  using namespace std::string_literals;

  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str)
    return property("statistics", this->_statistics, o.statistics);
  if ("groups"s == str)
    return property("groups", this->_groups, o.groups);
  if ("tileset"s == str)
    return property("tileset", this->_tileset, o.tileset);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionSubtree3dTilesMetadataLegacyJsonHandler.h"

#include <Cesium3DTiles/ExtensionSubtree3dTilesMetadataLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ExtensionSubtree3dTilesMetadataLegacyJsonHandler::
    ExtensionSubtree3dTilesMetadataLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classProperty(),
      _properties(context) {}

void ExtensionSubtree3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ExtensionSubtree3dTilesMetadataLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionSubtree3dTilesMetadataLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionSubtree3dTilesMetadataLegacy(
      Cesium3DTiles::ExtensionSubtree3dTilesMetadataLegacy::TypeName,
      str,
      *this->_pObject);
}

void ExtensionSubtree3dTilesMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              Cesium3DTiles::ExtensionSubtree3dTilesMetadataLegacy())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::ExtensionSubtree3dTilesMetadataLegacy&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionSubtree3dTilesMetadataLegacyJsonHandler::
    readObjectKeyExtensionSubtree3dTilesMetadataLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::ExtensionSubtree3dTilesMetadataLegacy& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTilingLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingLegacyJsonHandler::
    Extension3dTilesImplicitTilingLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _subdivisionScheme(),
      _subtreeLevels(),
      _maximumLevel(),
      _subtrees(context) {}

void Extension3dTilesImplicitTilingLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTilingLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTilingLegacy(
      Cesium3DTiles::Extension3dTilesImplicitTilingLegacy::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesImplicitTilingLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              Cesium3DTiles::Extension3dTilesImplicitTilingLegacy())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesImplicitTilingLegacy&>(
          value));
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingLegacyJsonHandler::
    readObjectKeyExtension3dTilesImplicitTilingLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTilingLegacy& o) {
  using namespace std::string_literals;

  if ("subdivisionScheme"s == str)
    return property(
        "subdivisionScheme",
        this->_subdivisionScheme,
        o.subdivisionScheme);
  if ("subtreeLevels"s == str)
    return property("subtreeLevels", this->_subtreeLevels, o.subtreeLevels);
  if ("maximumLevel"s == str)
    return property("maximumLevel", this->_maximumLevel, o.maximumLevel);
  if ("subtrees"s == str)
    return property("subtrees", this->_subtrees, o.subtrees);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingSubtreesLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTilingSubtreesLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingSubtreesLegacyJsonHandler::
    Extension3dTilesImplicitTilingSubtreesLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _uri() {}

void Extension3dTilesImplicitTilingSubtreesLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTilingSubtreesLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingSubtreesLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTilingSubtreesLegacy(
      Cesium3DTiles::Extension3dTilesImplicitTilingSubtreesLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingSubtreesLegacyJsonHandler::
    readObjectKeyExtension3dTilesImplicitTilingSubtreesLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTilingSubtreesLegacy& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataSubtreePropertyLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataSubtreePropertyLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataSubtreePropertyLegacyJsonHandler::
    Extension3dTilesMetadataSubtreePropertyLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _offsetType(),
      _arrayOffsetBufferView(),
      _stringOffsetBufferView() {}

void Extension3dTilesMetadataSubtreePropertyLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataSubtreePropertyLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataSubtreePropertyLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataSubtreePropertyLegacy(
      Cesium3DTiles::Extension3dTilesMetadataSubtreePropertyLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataSubtreePropertyLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataSubtreePropertyLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataSubtreePropertyLegacy& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("offsetType"s == str)
    return property("offsetType", this->_offsetType, o.offsetType);
  if ("arrayOffsetBufferView"s == str)
    return property(
        "arrayOffsetBufferView",
        this->_arrayOffsetBufferView,
        o.arrayOffsetBufferView);
  if ("stringOffsetBufferView"s == str)
    return property(
        "stringOffsetBufferView",
        this->_stringOffsetBufferView,
        o.stringOffsetBufferView);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataTilesetMetadataLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataTilesetMetadataLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataTilesetMetadataLegacyJsonHandler::
    Extension3dTilesMetadataTilesetMetadataLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _classProperty(),
      _properties() {}

void Extension3dTilesMetadataTilesetMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataTilesetMetadataLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataTilesetMetadataLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataTilesetMetadataLegacy(
      Cesium3DTiles::Extension3dTilesMetadataTilesetMetadataLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataTilesetMetadataLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataTilesetMetadataLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataTilesetMetadataLegacy& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataGroupMetadataLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataGroupMetadataLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataGroupMetadataLegacyJsonHandler::
    Extension3dTilesMetadataGroupMetadataLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _classProperty(),
      _properties() {}

void Extension3dTilesMetadataGroupMetadataLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataGroupMetadataLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataGroupMetadataLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataGroupMetadataLegacy(
      Cesium3DTiles::Extension3dTilesMetadataGroupMetadataLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataGroupMetadataLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataGroupMetadataLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataGroupMetadataLegacy& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataStatisticsLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataStatisticsLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataStatisticsLegacyJsonHandler::
    Extension3dTilesMetadataStatisticsLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classes(context) {}

void Extension3dTilesMetadataStatisticsLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataStatisticsLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataStatisticsLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataStatisticsLegacy(
      Cesium3DTiles::Extension3dTilesMetadataStatisticsLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataStatisticsLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataStatisticsLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataStatisticsLegacy& o) {
  using namespace std::string_literals;

  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataClassStatisticsLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataClassStatisticsLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataClassStatisticsLegacyJsonHandler::
    Extension3dTilesMetadataClassStatisticsLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _count(),
      _properties(context) {}

void Extension3dTilesMetadataClassStatisticsLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataClassStatisticsLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataClassStatisticsLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataClassStatisticsLegacy(
      Cesium3DTiles::Extension3dTilesMetadataClassStatisticsLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataClassStatisticsLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataClassStatisticsLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataClassStatisticsLegacy& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataPropertyStatisticsLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataPropertyStatisticsLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataPropertyStatisticsLegacyJsonHandler::
    Extension3dTilesMetadataPropertyStatisticsLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _min(),
      _max(),
      _mean(),
      _median(),
      _standardDeviation(),
      _variance(),
      _sum(),
      _occurrences() {}

void Extension3dTilesMetadataPropertyStatisticsLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataPropertyStatisticsLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataPropertyStatisticsLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataPropertyStatisticsLegacy(
      Cesium3DTiles::Extension3dTilesMetadataPropertyStatisticsLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataPropertyStatisticsLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataPropertyStatisticsLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataPropertyStatisticsLegacy& o) {
  using namespace std::string_literals;

  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("mean"s == str)
    return property("mean", this->_mean, o.mean);
  if ("median"s == str)
    return property("median", this->_median, o.median);
  if ("standardDeviation"s == str)
    return property(
        "standardDeviation",
        this->_standardDeviation,
        o.standardDeviation);
  if ("variance"s == str)
    return property("variance", this->_variance, o.variance);
  if ("sum"s == str)
    return property("sum", this->_sum, o.sum);
  if ("occurrences"s == str)
    return property("occurrences", this->_occurrences, o.occurrences);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataSchemaLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataSchemaLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataSchemaLegacyJsonHandler::
    Extension3dTilesMetadataSchemaLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _version(),
      _classes(context),
      _enums(context) {}

void Extension3dTilesMetadataSchemaLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataSchemaLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataSchemaLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataSchemaLegacy(
      Cesium3DTiles::Extension3dTilesMetadataSchemaLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataSchemaLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataSchemaLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataSchemaLegacy& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataEnumLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataEnumLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataEnumLegacyJsonHandler::
    Extension3dTilesMetadataEnumLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _valueType(),
      _values(context) {}

void Extension3dTilesMetadataEnumLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataEnumLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataEnumLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataEnumLegacy(
      Cesium3DTiles::Extension3dTilesMetadataEnumLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* Extension3dTilesMetadataEnumLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataEnumLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataEnumLegacy& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataEnumValueLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataEnumValueLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataEnumValueLegacyJsonHandler::
    Extension3dTilesMetadataEnumValueLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _value() {}

void Extension3dTilesMetadataEnumValueLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataEnumValueLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataEnumValueLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataEnumValueLegacy(
      Cesium3DTiles::Extension3dTilesMetadataEnumValueLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataEnumValueLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataEnumValueLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataEnumValueLegacy& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataClassLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataClassLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataClassLegacyJsonHandler::
    Extension3dTilesMetadataClassLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _properties(context) {}

void Extension3dTilesMetadataClassLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataClassLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataClassLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataClassLegacy(
      Cesium3DTiles::Extension3dTilesMetadataClassLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* Extension3dTilesMetadataClassLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataClassLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataClassLegacy& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMetadataClassPropertyLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMetadataClassPropertyLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMetadataClassPropertyLegacyJsonHandler::
    Extension3dTilesMetadataClassPropertyLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _type(),
      _enumType(),
      _componentCount(),
      _normalized(),
      _max(),
      _min(),
      _defaultProperty(),
      _optional(),
      _semantic() {}

void Extension3dTilesMetadataClassPropertyLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMetadataClassPropertyLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataClassPropertyLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMetadataClassPropertyLegacy(
      Cesium3DTiles::Extension3dTilesMetadataClassPropertyLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMetadataClassPropertyLegacyJsonHandler::
    readObjectKeyExtension3dTilesMetadataClassPropertyLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMetadataClassPropertyLegacy& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("componentCount"s == str)
    return property("componentCount", this->_componentCount, o.componentCount);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("optional"s == str)
    return property("optional", this->_optional, o.optional);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingSubtreeLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTilingSubtreeLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingSubtreeLegacyJsonHandler::
    Extension3dTilesImplicitTilingSubtreeLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffers(context),
      _bufferViews(context),
      _tileAvailability(context),
      _childSubtreeAvailability(context),
      _contentAvailability(context) {}

void Extension3dTilesImplicitTilingSubtreeLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTilingSubtreeLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingSubtreeLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTilingSubtreeLegacy(
      Cesium3DTiles::Extension3dTilesImplicitTilingSubtreeLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingSubtreeLegacyJsonHandler::
    readObjectKeyExtension3dTilesImplicitTilingSubtreeLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTilingSubtreeLegacy& o) {
  using namespace std::string_literals;

  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("tileAvailability"s == str)
    return property(
        "tileAvailability",
        this->_tileAvailability,
        o.tileAvailability);
  if ("childSubtreeAvailability"s == str)
    return property(
        "childSubtreeAvailability",
        this->_childSubtreeAvailability,
        o.childSubtreeAvailability);
  if ("contentAvailability"s == str)
    return property(
        "contentAvailability",
        this->_contentAvailability,
        o.contentAvailability);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingAvailabilityLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTilingAvailabilityLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingAvailabilityLegacyJsonHandler::
    Extension3dTilesImplicitTilingAvailabilityLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _availableCount(),
      _constant() {}

void Extension3dTilesImplicitTilingAvailabilityLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTilingAvailabilityLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingAvailabilityLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTilingAvailabilityLegacy(
      Cesium3DTiles::Extension3dTilesImplicitTilingAvailabilityLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingAvailabilityLegacyJsonHandler::
    readObjectKeyExtension3dTilesImplicitTilingAvailabilityLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTilingAvailabilityLegacy& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("availableCount"s == str)
    return property("availableCount", this->_availableCount, o.availableCount);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingBufferViewLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTilingBufferViewLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingBufferViewLegacyJsonHandler::
    Extension3dTilesImplicitTilingBufferViewLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _name() {}

void Extension3dTilesImplicitTilingBufferViewLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTilingBufferViewLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingBufferViewLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTilingBufferViewLegacy(
      Cesium3DTiles::Extension3dTilesImplicitTilingBufferViewLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingBufferViewLegacyJsonHandler::
    readObjectKeyExtension3dTilesImplicitTilingBufferViewLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTilingBufferViewLegacy& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingBufferLegacyJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTilingBufferLegacy.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingBufferLegacyJsonHandler::
    Extension3dTilesImplicitTilingBufferLegacyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _uri(),
      _byteLength(),
      _name() {}

void Extension3dTilesImplicitTilingBufferLegacyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTilingBufferLegacy* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingBufferLegacyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTilingBufferLegacy(
      Cesium3DTiles::Extension3dTilesImplicitTilingBufferLegacy::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingBufferLegacyJsonHandler::
    readObjectKeyExtension3dTilesImplicitTilingBufferLegacy(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTilingBufferLegacy& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "StatisticsJsonHandler.h"

#include <Cesium3DTiles/Statistics.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

StatisticsJsonHandler::StatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classes(context) {}

void StatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Statistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
StatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyStatistics(
      Cesium3DTiles::Statistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* StatisticsJsonHandler::readObjectKeyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Statistics& o) {
  using namespace std::string_literals;

  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassStatisticsJsonHandler.h"

#include <Cesium3DTiles/ClassStatistics.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ClassStatisticsJsonHandler::ClassStatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _count(),
      _properties(context) {}

void ClassStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ClassStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassStatistics(
      Cesium3DTiles::ClassStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKeyClassStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ClassStatistics& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyStatisticsJsonHandler.h"

#include <Cesium3DTiles/PropertyStatistics.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertyStatisticsJsonHandler::PropertyStatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _min(),
      _max(),
      _mean(),
      _median(),
      _standardDeviation(),
      _variance(),
      _sum(),
      _occurrences() {}

void PropertyStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyStatistics(
      Cesium3DTiles::PropertyStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKeyPropertyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyStatistics& o) {
  using namespace std::string_literals;

  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("mean"s == str)
    return property("mean", this->_mean, o.mean);
  if ("median"s == str)
    return property("median", this->_median, o.median);
  if ("standardDeviation"s == str)
    return property(
        "standardDeviation",
        this->_standardDeviation,
        o.standardDeviation);
  if ("variance"s == str)
    return property("variance", this->_variance, o.variance);
  if ("sum"s == str)
    return property("sum", this->_sum, o.sum);
  if ("occurrences"s == str)
    return property("occurrences", this->_occurrences, o.occurrences);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SchemaJsonHandler.h"

#include <Cesium3DTiles/Schema.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SchemaJsonHandler::SchemaJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _id(),
      _name(),
      _description(),
      _version(),
      _classes(context),
      _enums(context) {}

void SchemaJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Schema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SchemaJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySchema(
      Cesium3DTiles::Schema::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SchemaJsonHandler::readObjectKeySchema(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Schema& o) {
  using namespace std::string_literals;

  if ("id"s == str)
    return property("id", this->_id, o.id);
  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumJsonHandler.h"

#include <Cesium3DTiles/Enum.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

EnumJsonHandler::EnumJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _valueType(),
      _values(context) {}

void EnumJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Enum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnum(
      Cesium3DTiles::Enum::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumJsonHandler::readObjectKeyEnum(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Enum& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumValueJsonHandler.h"

#include <Cesium3DTiles/EnumValue.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

EnumValueJsonHandler::EnumValueJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _value() {}

void EnumValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::EnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumValueJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnumValue(
      Cesium3DTiles::EnumValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumValueJsonHandler::readObjectKeyEnumValue(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::EnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassJsonHandler.h"

#include <Cesium3DTiles/Class.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ClassJsonHandler::ClassJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _properties(context) {}

void ClassJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Class* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClass(
      Cesium3DTiles::Class::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassJsonHandler::readObjectKeyClass(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Class& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassPropertyJsonHandler.h"

#include <Cesium3DTiles/ClassProperty.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ClassPropertyJsonHandler::ClassPropertyJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _type(),
      _componentType(),
      _enumType(),
      _array(),
      _count(),
      _normalized(),
      _offset(),
      _scale(),
      _max(),
      _min(),
      _required(),
      _noData(),
      _defaultProperty(),
      _semantic() {}

void ClassPropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassProperty(
      Cesium3DTiles::ClassProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKeyClassProperty(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("array"s == str)
    return property("array", this->_array, o.array);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("required"s == str)
    return property("required", this->_required, o.required);
  if ("noData"s == str)
    return property("noData", this->_noData, o.noData);
  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreeJsonHandler.h"

#include <Cesium3DTiles/Subtree.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreeJsonHandler::SubtreeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffers(context),
      _bufferViews(context),
      _propertyTables(context),
      _tileAvailability(context),
      _contentAvailability(context),
      _childSubtreeAvailability(context),
      _tileMetadata(),
      _contentMetadata(),
      _subtreeMetadata(context) {}

void SubtreeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtree* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtree(
      Cesium3DTiles::Subtree::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreeJsonHandler::readObjectKeySubtree(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtree& o) {
  using namespace std::string_literals;

  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("propertyTables"s == str)
    return property("propertyTables", this->_propertyTables, o.propertyTables);
  if ("tileAvailability"s == str)
    return property(
        "tileAvailability",
        this->_tileAvailability,
        o.tileAvailability);
  if ("contentAvailability"s == str)
    return property(
        "contentAvailability",
        this->_contentAvailability,
        o.contentAvailability);
  if ("childSubtreeAvailability"s == str)
    return property(
        "childSubtreeAvailability",
        this->_childSubtreeAvailability,
        o.childSubtreeAvailability);
  if ("tileMetadata"s == str)
    return property("tileMetadata", this->_tileMetadata, o.tileMetadata);
  if ("contentMetadata"s == str)
    return property(
        "contentMetadata",
        this->_contentMetadata,
        o.contentMetadata);
  if ("subtreeMetadata"s == str)
    return property(
        "subtreeMetadata",
        this->_subtreeMetadata,
        o.subtreeMetadata);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MetadataEntityJsonHandler.h"

#include <Cesium3DTiles/MetadataEntity.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

MetadataEntityJsonHandler::MetadataEntityJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classProperty(),
      _properties() {}

void MetadataEntityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::MetadataEntity* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MetadataEntityJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMetadataEntity(
      Cesium3DTiles::MetadataEntity::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MetadataEntityJsonHandler::readObjectKeyMetadataEntity(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::MetadataEntity& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AvailabilityJsonHandler.h"

#include <Cesium3DTiles/Availability.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AvailabilityJsonHandler::AvailabilityJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bitstream(),
      _availableCount(),
      _constant() {}

void AvailabilityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Availability* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAvailability(
      Cesium3DTiles::Availability::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKeyAvailability(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Availability& o) {
  using namespace std::string_literals;

  if ("bitstream"s == str)
    return property("bitstream", this->_bitstream, o.bitstream);
  if ("availableCount"s == str)
    return property("availableCount", this->_availableCount, o.availableCount);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTableJsonHandler.h"

#include <Cesium3DTiles/PropertyTable.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertyTableJsonHandler::PropertyTableJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _classProperty(),
      _count(),
      _properties(context) {}

void PropertyTableJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTable(
      Cesium3DTiles::PropertyTable::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKeyPropertyTable(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyTable& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTablePropertyJsonHandler.h"

#include <Cesium3DTiles/PropertyTableProperty.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertyTablePropertyJsonHandler::PropertyTablePropertyJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _values(),
      _arrayOffsets(),
      _stringOffsets(),
      _arrayOffsetType(),
      _stringOffsetType(),
      _offset(),
      _scale(),
      _max(),
      _min() {}

void PropertyTablePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTableProperty(
      Cesium3DTiles::PropertyTableProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKeyPropertyTableProperty(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyTableProperty& o) {
  using namespace std::string_literals;

  if ("values"s == str)
    return property("values", this->_values, o.values);
  if ("arrayOffsets"s == str)
    return property("arrayOffsets", this->_arrayOffsets, o.arrayOffsets);
  if ("stringOffsets"s == str)
    return property("stringOffsets", this->_stringOffsets, o.stringOffsets);
  if ("arrayOffsetType"s == str)
    return property(
        "arrayOffsetType",
        this->_arrayOffsetType,
        o.arrayOffsetType);
  if ("stringOffsetType"s == str)
    return property(
        "stringOffsetType",
        this->_stringOffsetType,
        o.stringOffsetType);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"

#include <Cesium3DTiles/BufferView.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferViewJsonHandler::BufferViewJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _name() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BufferView* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(
      Cesium3DTiles::BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"

#include <Cesium3DTiles/Buffer.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferJsonHandler::BufferJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _uri(),
      _byteLength(),
      _name() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Buffer* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(
      Cesium3DTiles::Buffer::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TilesetJsonHandler.h"

#include <Cesium3DTiles/Tileset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TilesetJsonHandler::TilesetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _asset(context),
      _properties(context),
      _schema(context),
      _schemaUri(),
      _statistics(context),
      _groups(context),
      _metadata(context),
      _geometricError(),
      _root(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void TilesetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tileset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TilesetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTileset(
      Cesium3DTiles::Tileset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TilesetJsonHandler::readObjectKeyTileset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tileset& o) {
  using namespace std::string_literals;

  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);
  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str)
    return property("statistics", this->_statistics, o.statistics);
  if ("groups"s == str)
    return property("groups", this->_groups, o.groups);
  if ("metadata"s == str)
    return property("metadata", this->_metadata, o.metadata);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("root"s == str)
    return property("root", this->_root, o.root);
  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TileJsonHandler.h"

#include <Cesium3DTiles/Tile.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TileJsonHandler::TileJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _viewerRequestVolume(context),
      _geometricError(),
      _refine(),
      _transform(),
      _content(context),
      _contents(context),
      _metadata(context),
      _implicitTiling(context),
      _children(context) {}

void TileJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tile* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TileJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTile(
      Cesium3DTiles::Tile::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TileJsonHandler::readObjectKeyTile(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tile& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("viewerRequestVolume"s == str)
    return property(
        "viewerRequestVolume",
        this->_viewerRequestVolume,
        o.viewerRequestVolume);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("refine"s == str)
    return property("refine", this->_refine, o.refine);
  if ("transform"s == str)
    return property("transform", this->_transform, o.transform);
  if ("content"s == str)
    return property("content", this->_content, o.content);
  if ("contents"s == str)
    return property("contents", this->_contents, o.contents);
  if ("metadata"s == str)
    return property("metadata", this->_metadata, o.metadata);
  if ("implicitTiling"s == str)
    return property("implicitTiling", this->_implicitTiling, o.implicitTiling);
  if ("children"s == str)
    return property("children", this->_children, o.children);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ImplicitTilingJsonHandler.h"

#include <Cesium3DTiles/ImplicitTiling.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ImplicitTilingJsonHandler::ImplicitTilingJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _subdivisionScheme(),
      _subtreeLevels(),
      _availableLevels(),
      _subtrees(context) {}

void ImplicitTilingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ImplicitTiling* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ImplicitTilingJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyImplicitTiling(
      Cesium3DTiles::ImplicitTiling::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ImplicitTilingJsonHandler::readObjectKeyImplicitTiling(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ImplicitTiling& o) {
  using namespace std::string_literals;

  if ("subdivisionScheme"s == str)
    return property(
        "subdivisionScheme",
        this->_subdivisionScheme,
        o.subdivisionScheme);
  if ("subtreeLevels"s == str)
    return property("subtreeLevels", this->_subtreeLevels, o.subtreeLevels);
  if ("availableLevels"s == str)
    return property(
        "availableLevels",
        this->_availableLevels,
        o.availableLevels);
  if ("subtrees"s == str)
    return property("subtrees", this->_subtrees, o.subtrees);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreesJsonHandler.h"

#include <Cesium3DTiles/Subtrees.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreesJsonHandler::SubtreesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _uri() {}

void SubtreesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtrees* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtrees(
      Cesium3DTiles::Subtrees::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreesJsonHandler::readObjectKeySubtrees(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtrees& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ContentJsonHandler.h"

#include <Cesium3DTiles/Content.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ContentJsonHandler::ContentJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _uri(),
      _metadata(context),
      _group() {}

void ContentJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Content* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ContentJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyContent(
      Cesium3DTiles::Content::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ContentJsonHandler::readObjectKeyContent(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Content& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("metadata"s == str)
    return property("metadata", this->_metadata, o.metadata);
  if ("group"s == str)
    return property("group", this->_group, o.group);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BoundingVolumeJsonHandler.h"

#include <Cesium3DTiles/BoundingVolume.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BoundingVolumeJsonHandler::BoundingVolumeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _box(),
      _region(),
      _sphere() {}

void BoundingVolumeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BoundingVolume* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBoundingVolume(
      Cesium3DTiles::BoundingVolume::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKeyBoundingVolume(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BoundingVolume& o) {
  using namespace std::string_literals;

  if ("box"s == str)
    return property("box", this->_box, o.box);
  if ("region"s == str)
    return property("region", this->_region, o.region);
  if ("sphere"s == str)
    return property("sphere", this->_sphere, o.sphere);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "GroupMetadataJsonHandler.h"

#include <Cesium3DTiles/GroupMetadata.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

GroupMetadataJsonHandler::GroupMetadataJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : MetadataEntityJsonHandler(context) {}

void GroupMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::GroupMetadata* pObject) {
  MetadataEntityJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
GroupMetadataJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyGroupMetadata(
      Cesium3DTiles::GroupMetadata::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
GroupMetadataJsonHandler::readObjectKeyGroupMetadata(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::GroupMetadata& o) {
  using namespace std::string_literals;

  (void)o;

  return this->readObjectKeyMetadataEntity(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertiesJsonHandler.h"

#include <Cesium3DTiles/Properties.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertiesJsonHandler::PropertiesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _maximum(),
      _minimum() {}

void PropertiesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Properties* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertiesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyProperties(
      Cesium3DTiles::Properties::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* PropertiesJsonHandler::readObjectKeyProperties(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Properties& o) {
  using namespace std::string_literals;

  if ("maximum"s == str)
    return property("maximum", this->_maximum, o.maximum);
  if ("minimum"s == str)
    return property("minimum", this->_minimum, o.minimum);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"

#include <Cesium3DTiles/Asset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AssetJsonHandler::AssetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _version(),
      _tilesetVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(
      Cesium3DTiles::Asset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Asset& o) {
  using namespace std::string_literals;

  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("tilesetVersion"s == str)
    return property("tilesetVersion", this->_tilesetVersion, o.tilesetVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
